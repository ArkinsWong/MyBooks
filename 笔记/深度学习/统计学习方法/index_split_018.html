<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>统计学习方法</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos696913" class="calibre_"><span class="calibre1"><span class="bold">附录A　梯度下降法</span></span></p><p class="calibre_13">梯度下降法（gradient descent）或最速下降法（steepest descent）是求解无约束最优化问题的一种最常用的方法，有实现简单的优点。梯度下降法是迭代算法，每一步需要求解目标函数的梯度向量。</p><p class="calibre_8">假设f(x)是R<sup class="calibre5"><small class="calibre6"><span class="calibre7">n</span></small></sup>上具有一阶连续偏导数的函数。要求解的无约束最优化问题是</p><p class="calibre_20"><img src="images/00017.jpg" class="calibre_955"/></p><p class="calibre_22">x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>表示目标函数f(x)的极小点。</p><p class="calibre_8">梯度下降法是一种迭代算法。选取适当的初值x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(0)</span></small></sup>，不断迭代，更新x的值，进行目标函数的极小化，直到收敛。由于负梯度方向是使函数值下降最快的方向，在迭代的每一步，以负梯度方向更新x的值，从而达到减少函数值的目的。</p><p class="calibre_8">由于f(x)具有一阶连续偏导数，若第k次迭代值为x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>，则可将f(x)在x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>附近进行一阶泰勒展开：</p><p class="calibre_20"><img src="images/00572.jpg" class="calibre_956"/></p><p class="calibre_22">这里，g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)＝<img src="images/00895.jpg" class="calibre_375"/>f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)为f(x)在x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>的梯度。</p><p class="calibre_8">求出第k+1次迭代值x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>：</p><p class="calibre_20"><img src="images/00766.jpg" class="calibre_957"/></p><p class="calibre_22">其中，p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是搜索方向，取负梯度方向p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝-<img src="images/00895.jpg" class="calibre_375"/>f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)，<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是步长，由一维搜索确定，即<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>使得</p><p class="calibre_20"><img src="images/00437.jpg" class="calibre_958"/></p><p class="calibre_24">梯度下降法算法如下：</p><p class="calibre_146"><span class="bold">算法A.1（梯度下降法）</span></p><p class="calibre_146">输入：目标函数f(x)，梯度函数g(x)＝<img src="images/00895.jpg" class="calibre_375"/>f(x)，计算精度<img src="images/00860.jpg" class="calibre_76"/>；</p><p class="calibre_8">输出：f(x)的极小点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>。</p><p class="calibre_8">（1）取初始值x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(0)</span></small></sup>∊R<sup class="calibre5"><small class="calibre6"><span class="calibre7">n</span></small></sup>，置k＝0</p><p class="calibre_8">（2）计算f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)</p><p class="calibre_8">（3）计算梯度g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)，当||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>时，停止迭代，令x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>；否则，令p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝-g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)，求<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，使</p><p class="calibre_20"><img src="images/00983.jpg" class="calibre_959"/></p><p class="calibre_24">（4）置x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>+<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，计算f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>)</p><p class="calibre_8">当||f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>)-f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)||&lt;<img src="images/00860.jpg" class="calibre_76"/>或||x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>-x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>||&lt;<img src="images/00860.jpg" class="calibre_76"/>时，停止迭代，令x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup></p><p class="calibre_8">（5）否则，置k＝k+1，转（3）。</p><p class="calibre_8">当目标函数是凸函数时，梯度下降法的解是全局最优解。一般情况下，其解不保证是全局最优解。梯度下降法的收敛速度也未必是很快的。</p><div class="mbp_pagebreak" id="calibre_pb_18"></div>
</body></html>
