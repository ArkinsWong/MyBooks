<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>统计学习方法</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos702480" class="calibre_"><span class="calibre1"><span class="bold">附录B　牛顿法和拟牛顿法</span></span></p><p class="calibre_13">牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是求解无约束最优化问题的常用方法，有收敛速度快的优点。牛顿法是迭代算法，每一步需要求解目标函数的海赛矩阵的逆矩阵，计算比较复杂。拟牛顿法通过正定矩阵近似海赛矩阵的逆矩阵或海赛矩阵，简化了这一计算过程。</p><p class="calibre_7"><span class="bold">1．牛顿法</span></p><p class="calibre_7">考虑无约束最优化问题</p><p class="calibre_20"><img src="images/00025.jpg" class="calibre_960"/></p><p class="calibre_22">其中x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>为目标函数的极小点。</p><p class="calibre_8">假设f(x)具有二阶连续偏导数，若第k次迭代值为x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>，则可将f(x)在x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>附近进行二阶泰勒展开：</p><p class="calibre_20"><img src="images/00132.jpg" class="calibre_961"/></p><p class="calibre_22">这里，g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)＝<img src="images/00895.jpg" class="calibre_375"/>f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)是f(x)的梯度向量在点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>的值，H(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)是f(x)的海赛矩阵（Hesse matrix）</p><p class="calibre_20"><img src="images/00241.jpg" class="calibre_962"/></p><p class="calibre_22">在点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>的值。函数f(x)有极值的必要条件是在极值点处一阶导数为0，即梯度向量为0。特别是当H(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)是正定矩阵时，函数f(x)的极值为极小值。</p><p class="calibre_8">牛顿法利用极小点的必要条件</p><p class="calibre_20"><img src="images/00348.jpg" class="calibre_963"/></p><p class="calibre_22">每次迭代中从点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>开始，求目标函数的极小点，作为第k+1次迭代值x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>。具体地，假设x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>满足：</p><p class="calibre_20"><img src="images/01070.jpg" class="calibre_964"/></p><p class="calibre_22">由式（B.2）有</p><p class="calibre_20"><img src="images/00107.jpg" class="calibre_965"/></p><p class="calibre_22">其中H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝H(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)。这样，式（B.5）成为</p><p class="calibre_20"><img src="images/00624.jpg" class="calibre_966"/></p><p class="calibre_22">因此，</p><p class="calibre_20"><img src="images/00008.jpg" class="calibre_558"/></p><p class="calibre_22">或者</p><p class="calibre_20"><img src="images/00770.jpg" class="calibre_967"/></p><p class="calibre_22">其中，</p><p class="calibre_20"><img src="images/00549.jpg" class="calibre_968"/></p><p class="calibre_22">用式（B.8）作为迭代公式的算法就是牛顿法。</p><p class="calibre_146"><span class="bold">算法B.1（牛顿法）</span></p><p class="calibre_146">输入：目标函数f(x)，梯度g(x)＝<img src="images/00895.jpg" class="calibre_375"/>f(x)，海赛矩阵H(x)，精度要求<img src="images/00860.jpg" class="calibre_76"/>；</p><p class="calibre_8">输出：f(x)的极小点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>。</p><p class="calibre_8">（1）取初始点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(0)</span></small></sup>，置k＝0</p><p class="calibre_8">（2）计算g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)</p><p class="calibre_8">（3）若||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>，则停止计算，得近似解x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup></p><p class="calibre_8">（4）计算H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝H(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)，并求p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_20"><img src="images/00665.jpg" class="calibre_969"/></p><p class="calibre_24">（5）置x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>+p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_8">（6）置k＝k+1，转（2）。</p><p class="calibre_8">步骤（4）求p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，<img src="images/00771.jpg" class="calibre_843"/>，要求<img src="images/00876.jpg" class="calibre_970"/>，计算比较复杂，所以有其他改进的方法。</p><p class="calibre_7"><span class="bold">2．拟牛顿法的思路</span></p><p class="calibre_7">在牛顿法的迭代中，需要计算海赛矩阵的逆矩阵H<sup class="calibre5"><small class="calibre6"><span class="calibre7">-1</span></small></sup>，这一计算比较复杂，考虑用一个n阶矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝G(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)来近似代替<img src="images/00986.jpg" class="calibre_902"/>。这就是拟牛顿法的基本想法。</p><p class="calibre_8">先看牛顿法迭代中海赛矩阵H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足的条件。首先，H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足以下关系。在式（B.6）中取x＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>，即得</p><p class="calibre_20"><img src="images/00649.jpg" class="calibre_971"/></p><p class="calibre_22">记y<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>-g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，<img src="images/00850.jpg" class="calibre_73"/>k＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>-x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>，则</p><p class="calibre_20"><img src="images/00134.jpg" class="calibre_972"/></p><p class="calibre_22">或</p><p class="calibre_20"><img src="images/00250.jpg" class="calibre_973"/></p><p class="calibre_22">式（B.12）或式（B.13）称为拟牛顿条件。</p><p class="calibre_8">如果H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是正定的（<img src="images/00876.jpg" class="calibre_970"/>也是正定的），那么可以保证牛顿法搜索方向p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是下降方向。这是因为搜索方向是p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝-<img src="images/00759.jpg" class="calibre_47"/>g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，由式（B.8）有</p><p class="calibre_20"><img src="images/00352.jpg" class="calibre_974"/></p><p class="calibre_22">所以f(x)在x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>的泰勒展开式（B.2）可以近似写成：</p><p class="calibre_20"><img src="images/00460.jpg" class="calibre_975"/></p><p class="calibre_22">因<img src="images/00876.jpg" class="calibre_970"/>正定，故有<img src="images/00581.jpg" class="calibre_976"/>。当<img src="images/00759.jpg" class="calibre_47"/>为一个充分小的正数时，总有f(x)&lt;f(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)，也就是说p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是下降方向。</p><p class="calibre_8">拟牛顿法将G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>作为<img src="images/00876.jpg" class="calibre_970"/>的近似，要求矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足同样的条件。首先，每次迭代矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是正定的。同时，G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足下面的拟牛顿条件：</p><p class="calibre_20"><img src="images/00689.jpg" class="calibre_977"/></p><p class="calibre_24">按照拟牛顿条件选择G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>作为<img src="images/00876.jpg" class="calibre_970"/>的近似或选择B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>作为H<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的近似的算法称为拟牛顿法。</p><p class="calibre_8">按照拟牛顿条件，在每次迭代中可以选择更新矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>：</p><p class="calibre_20"><img src="images/00799.jpg" class="calibre_978"/></p><p class="calibre_22">这种选择有一定的灵活性，因此有多种具体实现方法。下面介绍Broyden类拟牛顿法。</p><p class="calibre_7"><span class="bold">3．DFP（Davidon-Fletcher-Powell）算法（DFP algorithm）</span></p><p class="calibre_7">DFP算法选择G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>的方法是，假设每一步迭代中矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>是由G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>加上两个附加项构成的，即</p><p class="calibre_20"><img src="images/00902.jpg" class="calibre_979"/></p><p class="calibre_22">其中P<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，Q<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>是待定矩阵。这时，</p><p class="calibre_20"><img src="images/01013.jpg" class="calibre_638"/></p><p class="calibre_22">为使G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>满足拟牛顿条件，可使P<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>和Q<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足：</p><p class="calibre_20"><img src="images/00825.jpg" class="calibre_980"/></p><p class="calibre_22">事实上，不难找出这样的P<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>和Q<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，例如取</p><p class="calibre_20"><img src="images/00161.jpg" class="calibre_981"/></p><p class="calibre_22">这样就可得到矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>的迭代公式：</p><p class="calibre_20"><img src="images/00816.jpg" class="calibre_347"/></p><p class="calibre_22">称为DFP算法。</p><p class="calibre_8">可以证明，如果初始矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">0</span></small></sub>是正定的，则迭代过程中的每个矩阵G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>都是正定的。</p><p class="calibre_8">DFP算法如下：</p><p class="calibre_146"><span class="bold">算法B.2（DFP算法）</span></p><p class="calibre_146">输入：目标函数f(x)，梯度g(x)＝<img src="images/00895.jpg" class="calibre_375"/>f(x)，精度要求<img src="images/00860.jpg" class="calibre_76"/>；</p><p class="calibre_8">输出：f(x)的极小点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>。</p><p class="calibre_8">（1）选定初始点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(0)</span></small></sup>，取G<sub class="calibre8"><small class="calibre6"><span class="calibre7">0</span></small></sub>为正定对称矩阵，置k＝0</p><p class="calibre_8">（2）计算g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)。若||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>，则停止计算，得近似解x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>；否则转（3）</p><p class="calibre_8">（3）置p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝-G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub> g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_8">（4）一维搜索：求<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>使得</p><p class="calibre_20"><img src="images/00286.jpg" class="calibre_982"/></p><p class="calibre_24">（5）置x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>+<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_8">（6）计算g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>)，若||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>，则停止计算，得近似解x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>；否则，按式（B.23）算出G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub></p><p class="calibre_8">（7）置k＝k+1，转（3）。</p><p class="calibre_7"><span class="bold">4．BFGS（Broyden-Fletcher-Goldfarb-Shanno）算法（BFGS algorithm）</span></p><p class="calibre_7">BFGS算法是最流行的拟牛顿算法。</p><p class="calibre_8">可以考虑用G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>逼近海赛矩阵的逆矩阵H<sup class="calibre5"><small class="calibre6"><span class="calibre7">-1</span></small></sup>，也可以考虑用B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>逼近海赛矩阵H。</p><p class="calibre_8">这时，相应的拟牛顿条件是</p><p class="calibre_20"><img src="images/00490.jpg" class="calibre_983"/></p><p class="calibre_22">可以用同样的方法得到另一迭代公式。首先令</p><p class="calibre_20"><img src="images/00315.jpg" class="calibre_984"/></p><p class="calibre_20"><img src="images/00168.jpg" class="calibre_985"/></p><p class="calibre_22">考虑使P<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>和Q<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>满足：</p><p class="calibre_20"><img src="images/00477.jpg" class="calibre_986"/></p><p class="calibre_22">找出适合条件的P<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>和Q<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>，得到BFGS算法矩阵B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>的迭代公式：</p><p class="calibre_20"><img src="images/00896.jpg" class="calibre_987"/></p><p class="calibre_24">可以证明，如果初始矩阵B<sub class="calibre8"><small class="calibre6"><span class="calibre7">0</span></small></sub>是正定的，则迭代过程中的每个矩阵B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>都是正定的。</p><p class="calibre_8">下面写出BFGS拟牛顿算法。</p><p class="calibre_146"><span class="bold">算法B.3（BFGS算法）</span></p><p class="calibre_146">输入：目标函数f(x)，g(x)＝<img src="images/00895.jpg" class="calibre_375"/>f(x)，精度要求<img src="images/00860.jpg" class="calibre_76"/>；</p><p class="calibre_8">输出：f(x)的极小点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>。</p><p class="calibre_8">（1）选定初始点x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(0)</span></small></sup>，取B<sub class="calibre8"><small class="calibre6"><span class="calibre7">0</span></small></sub>为正定对称矩阵，置k＝0</p><p class="calibre_8">（2）计算g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>)。若||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>，则停止计算，得近似解x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>；否则转（3）</p><p class="calibre_8">（3）由B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub> p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>＝-g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>求出p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_8">（4）一维搜索：求<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>使得</p><p class="calibre_20"><img src="images/01042.jpg" class="calibre_988"/></p><p class="calibre_24">（5）置x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k)</span></small></sup>+<img src="images/00759.jpg" class="calibre_47"/><sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>p<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub></p><p class="calibre_8">（6）计算g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>＝g(x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>)，若||g<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>||&lt;<img src="images/00860.jpg" class="calibre_76"/>，则停止计算，得近似解x<sup class="calibre5"><small class="calibre6"><span class="calibre7">*</span></small></sup>＝x<sup class="calibre5"><small class="calibre6"><span class="calibre7">(k+1)</span></small></sup>；否则，按式（B.30）算出B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub></p><p class="calibre_8">（7）置k＝k+1，转（3）。</p><p class="calibre_7"><span class="bold">5．Broyden类算法（Broyden’s algorithm）</span></p><p class="calibre_7">我们可以从BFGS算法矩阵B<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的迭代公式（B.30）得到BFGS算法关于G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的迭代公式。事实上，若记<img src="images/00085.jpg" class="calibre_989"/>那么对式（B.30）两次应用ShermanMorrisn公式<sup class="calibre5"><small id="filepos721674" class="calibre6"><a href="#filepos722876"><span class="calibre7">[1]</span></a></small></sup>即得</p><p class="calibre_20"><img src="images/00022.jpg" class="calibre_990"/></p><p class="calibre_22">称为BFGS算法关于G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的迭代公式。</p><p class="calibre_8">由DFP算法G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的迭代公式（B.23）得到的G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>记作G<sup class="calibre5"><small class="calibre6"><span class="calibre7">DFP</span></small></sup>，由BFGS算法G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k</span></small></sub>的迭代公式（B.31）得到的G<sub class="calibre8"><small class="calibre6"><span class="calibre7">k+1</span></small></sub>记作G<sup class="calibre5"><small class="calibre6"><span class="calibre7">BFGS</span></small></sup>，它们都满足方程拟牛顿条件式，所以它们的线性组合</p><p class="calibre_20"><img src="images/00954.jpg" class="calibre_991"/></p><p class="calibre_22">也满足拟牛顿条件式，而且是正定的。其中0≤a≤1。这样就得到了一类拟牛顿法，称为Broyden类算法。</p><p class="calibre_98"><span class="calibre2"><span class="bold">注释</span></span></p><p id="filepos722876" class="calibre_99"><a href="#filepos721674"><span class="calibre4">[1]</span></a><span class="calibre4">　Sherman-Morrison公式：假设A是n阶可逆矩阵，u,v是n维向量，且A+uv<sup class="calibre10"><small class="calibre6"><span class="calibre7">T</span></small></sup>也是可逆矩阵，则</span></p><p class="calibre_20"><img src="images/00408.jpg" class="calibre_992"/></p><div class="mbp_pagebreak" id="calibre_pb_19"></div>
</body></html>
